using CaseGen.Functions.Models;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using System.Text.Json;

namespace CaseGen.Functions.Services;

public class ImagesService : IImagesService
{
    private readonly IStorageService _storageService;
    private readonly IConfiguration _configuration;
    private readonly ILogger<ImagesService> _logger;

    public ImagesService(
        IStorageService storageService,
        IConfiguration configuration,
        ILogger<ImagesService> logger)
    {
        _storageService = storageService;
        _configuration = configuration;
        _logger = logger;
    }

    public async Task<string> GenerateAsync(string caseId, MediaSpec spec, CancellationToken cancellationToken = default)
    {
        _logger.LogInformation("Generating real image for evidence {EvidenceId} of kind {Kind}", spec.EvidenceId, spec.Kind);

        // Check if this is an image type that should be generated
        if (!IsImageType(spec.Kind))
        {
            _logger.LogInformation("Skipping non-image media type {Kind} for evidence {EvidenceId}", spec.Kind, spec.EvidenceId);
            return await CreateDeferredResult(caseId, spec, "Non-image type deferred");
        }

        try
        {
            // Parse the media spec to get the generation prompt
            var mediaJson = JsonSerializer.Deserialize<JsonElement>(spec.Prompt);
            string genPrompt = "";
            
            if (mediaJson.TryGetProperty("genPrompt", out var promptElement))
            {
                genPrompt = promptElement.GetString() ?? "";
            }
            
            if (string.IsNullOrWhiteSpace(genPrompt))
            {
                _logger.LogWarning("No genPrompt found in media spec for evidence {EvidenceId}", spec.EvidenceId);
                return await CreateDeferredResult(caseId, spec, "No generation prompt available");
            }

            // For now, create a placeholder image since we need to set up the API properly
            // TODO: Implement actual OpenAI image generation once API is configured
            var imageBytes = await GeneratePlaceholderImage(genPrompt, spec, cancellationToken);
            
            // Save the image to blob storage within the bundle
            var imageUrl = await SaveImageToBundle(caseId, spec.EvidenceId, imageBytes, cancellationToken);
            
            // Create log entry
            await CreateImageLog(caseId, spec, imageUrl, imageBytes.Length, cancellationToken);
            
            _logger.LogInformation("Successfully generated and saved placeholder image for evidence {EvidenceId}: {Url}", spec.EvidenceId, imageUrl);
            
            return imageUrl;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to generate image for evidence {EvidenceId}", spec.EvidenceId);
            
            // Create error file in bundle
            await CreateErrorFile(caseId, spec.EvidenceId, ex.Message, cancellationToken);
            
            return await CreateDeferredResult(caseId, spec, $"Generation failed: {ex.Message}");
        }
    }

    private bool IsImageType(string kind)
    {
        return kind switch
        {
            MediaTypes.Photo => true,
            MediaTypes.DocumentScan => true,
            MediaTypes.Diagram => true,
            _ => false
        };
    }

    private async Task<byte[]> GeneratePlaceholderImage(string genPrompt, MediaSpec spec, CancellationToken cancellationToken)
    {
        _logger.LogInformation("Generating placeholder image for evidence {EvidenceId} with prompt: {Prompt}", 
            spec.EvidenceId, genPrompt);

        // Create a simple placeholder image as a JSON text file for now
        // In production, this would call OpenAI's image generation API
        var placeholderData = new
        {
            evidenceId = spec.EvidenceId,
            kind = spec.Kind,
            title = spec.Title,
            genPrompt = genPrompt,
            constraints = spec.Constraints,
            status = "PLACEHOLDER_GENERATED",
            note = "This is a placeholder. In production, this would be a real image generated by OpenAI DALL-E",
            generatedAt = DateTime.UtcNow
        };

        var jsonContent = JsonSerializer.Serialize(placeholderData, new JsonSerializerOptions { WriteIndented = true });
        return System.Text.Encoding.UTF8.GetBytes(jsonContent);
    }

    private async Task<string> SaveImageToBundle(string caseId, string evidenceId, byte[] imageBytes, CancellationToken cancellationToken)
    {
        var bundlesContainer = _configuration["CaseGeneratorStorage:BundlesContainer"] ?? "bundles";
        // Use .json extension for placeholder, would be .jpg for real images
        var imageFileName = $"{caseId}/media/{evidenceId}.placeholder.json";
        
        var imageUrl = await _storageService.SaveFileAsync(bundlesContainer, imageFileName, imageBytes, cancellationToken);
        
        _logger.LogInformation("BUNDLE: Saved generated placeholder image to bundle: {Path} (case={CaseId}, evidence={EvidenceId}, size={Size} bytes)",
            imageFileName, caseId, evidenceId, imageBytes.Length);
            
        return imageUrl;
    }

    private async Task CreateImageLog(string caseId, MediaSpec spec, string imageUrl, int sizeBytes, CancellationToken cancellationToken)
    {
        var logEntry = new
        {
            evidenceId = spec.EvidenceId,
            kind = spec.Kind,
            title = spec.Title,
            imageUrl = imageUrl,
            sizeBytes = sizeBytes,
            generatedAt = DateTime.UtcNow,
            status = "SUCCESS"
        };

        var logJson = JsonSerializer.Serialize(logEntry, new JsonSerializerOptions { WriteIndented = true });
        
        var bundlesContainer = _configuration["CaseGeneratorStorage:BundlesContainer"] ?? "bundles";
        var logFileName = $"{caseId}/logs/image-{spec.EvidenceId}.log.json";
        
        await _storageService.SaveFileAsync(bundlesContainer, logFileName, logJson, cancellationToken);
        
        _logger.LogInformation("Created image generation log for evidence {EvidenceId}", spec.EvidenceId);
    }

    private async Task CreateErrorFile(string caseId, string evidenceId, string error, CancellationToken cancellationToken)
    {
        var bundlesContainer = _configuration["CaseGeneratorStorage:BundlesContainer"] ?? "bundles";
        var errorFileName = $"{caseId}/media/{evidenceId}.error.txt";
        
        var errorContent = $"Image generation failed at {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC\nError: {error}";
        
        await _storageService.SaveFileAsync(bundlesContainer, errorFileName, errorContent, cancellationToken);
        
        _logger.LogInformation("Created error file for evidence {EvidenceId}: {FileName}", evidenceId, errorFileName);
    }

    private async Task<string> CreateDeferredResult(string caseId, MediaSpec spec, string reason, CancellationToken cancellationToken = default)
    {
        var deferredEntry = new
        {
            evidenceId = spec.EvidenceId,
            kind = spec.Kind,
            title = spec.Title,
            status = "DEFERRED",
            reason = reason,
            deferredAt = DateTime.UtcNow
        };

        var logJson = JsonSerializer.Serialize(deferredEntry, new JsonSerializerOptions { WriteIndented = true });
        
        var bundlesContainer = _configuration["CaseGeneratorStorage:BundlesContainer"] ?? "bundles";
        var logFileName = $"{caseId}/logs/image-{spec.EvidenceId}.deferred.json";
        
        await _storageService.SaveFileAsync(bundlesContainer, logFileName, logJson, cancellationToken);
        
        return $"DEFERRED: {reason}";
    }
}